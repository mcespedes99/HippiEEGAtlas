#---- begin snakebids boilerplate ----------------------------------------------

import snakebids
from snakebids import bids
from os.path import join
from itertools import compress
import fnmatch
import numpy as np
import pandas as pd


configfile: workflow.source_path('../config/snakebids.yml')

# Get input wildcards
inputs = snakebids.generate_inputs(
    bids_dir=config["bids_dir"],
    pybids_inputs=config["pybids_inputs"],
    pybids_database_dir=config.get("pybids_db_dir"),
    pybids_reset_database=config.get("pybids_db_reset"),
    derivatives=config.get("derivatives", None),
    participant_label=config.get("participant_label", None),
    exclude_participant_label=config.get("exclude_participant_label", None),
    use_bids_inputs=True,
)
subj_session_list = list(zip(inputs.zip_lists['ieeg']['subject'],inputs.zip_lists['ieeg']['session']))

#this adds constraints to the bids naming
wildcard_constraints:  **snakebids.get_wildcard_constraints(config['pybids_inputs'])

def get_inputs(input_path, **zip_lists):
    # Possible edf files
    annot_files = expand(
                input_path,
                zip,
                **zip_lists
            )
    # print(annot_files)
    # Convert zip list to tuples and add to a set
    set_wildcards_vals = set()
    list_wildcards_vals = []
    values_wildcards = list(zip_lists.values())
    for idx in range(len(annot_files)):
        tmp_tuple = tuple([value[idx] for value in values_wildcards])
        set_wildcards_vals.add(tmp_tuple)
        # Also save in list to use it in the filtering (an ordered list is needed)
        list_wildcards_vals.append(tmp_tuple)

    # Create remove set
    remove_set = set()
    # Check annotation files to filter inputs
    for idx, annot_file in enumerate(annot_files):
        # Open annotation file to check if any event is in the data
        annot = pd.read_csv(annot_file, sep='\t')
        # Find time stamps indexes where the 'awake trigger' event is happening
        # returns True on all the indexes if no event is found
        cond = ~annot['event'].str.contains('awake trigger', case=False)
        # If no event is found, then add to remove set
        if cond.all():
            remove_set.add(list_wildcards_vals[idx])
    # Get filtered values
    out_wildcards_vals = set_wildcards_vals-remove_set

    # First get dict keys
    out_ziplist_keys = list(zip_lists.keys())
    # Convert the set to list of lists
    out_ziplist_vals = []
    for key_id in range(len(out_ziplist_keys)):
        out_ziplist_vals.append([tuple_val[key_id] for tuple_val in out_wildcards_vals])
    # Construct dictionary
    out_ziplist = dict(zip(out_ziplist_keys, out_ziplist_vals))
    return out_ziplist

# Get filtered ziplist based on annotations of interest
filtered_ziplist = get_inputs(inputs.path['annotations'], **inputs.zip_lists['annotations'])


#---- end snakebids boilerplate ------------------------------------------------
rule epochs:
    input: 
        edf = inputs.path['ieeg'],
        annot = inputs.path['annotations'],
    params:
        script = join(workflow.basedir,'../code/epochs.py'),
        processes = workflow.cores,
        mem = config['memory']
    output:
        out_edf = bids(
                        root='bids',
                        datatype='ieeg',
                        suffix='ieeg_epoch.edf',
                        **inputs.wildcards['ieeg']
                  )
    threads: workflow.cores # Set equal to the number of cores to avoid parallel runs
    log:
        bids(
            root='logs',
            suffix='epochs.log',
            **inputs.wildcards['ieeg']
        ),
    script: join(workflow.basedir,'scripts/epochs.py')

rule all:
    input:
        expand(
            expand(
                rules.epochs.output,
                allow_missing=True,
            ),
            zip,
            **filtered_ziplist
        )
    default_target: True